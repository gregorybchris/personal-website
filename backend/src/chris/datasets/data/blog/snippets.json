[
  {
    "slug": "fail-fast-vs-defensive",
    "date": "2026-01-23",
    "text": "There's nothing inherently wrong with defensive programming, especially if you enjoy developing a codebase littered with foot guns.",
    "tags": ["programming-style"]
  },
  {
    "slug": "defensive-style-in-big-tech",
    "date": "2026-01-23",
    "text": "Theory: a preference for defensive programming over fail-fast correlates with big tech. Maybe because the price of whole system failure is higher at big tech. Maybe because there's a chance you might escape being assigned the bug down the line.",
    "tags": ["programming-style"]
  },
  {
    "slug": "make-your-ci-stable-and-required",
    "date": "2026-01-23",
    "text": "Don't run CI on your code if test failures won't block merge. It's a waste of compute. Similarly, CI tests should be stable modulo solar flares. Anything less stable should be a low severity alert.",
    "tags": ["engineering-process"]
  },
  {
    "slug": "monorepos-for-startups",
    "date": "2026-01-23",
    "text": "Small teams must be efficient with time. Code velocity is essential. Make choices that maximize reuse of work. Use a monorepo. Write CI/CD once. Enforce code quality strictly. Colocate code to promote collaboration, discoverability, and component reuse.",
    "tags": ["engineering-process"]
  },
  {
    "slug": "monorepo-ne-monolith",
    "date": "2026-01-23",
    "text": "Monorepo does not imply monolith. You can keep your code in one place while still having clear module boundaries and isolated components and services.",
    "tags": ["engineering-process"]
  },
  {
    "slug": "pr-reviews-are-a-courtesy",
    "date": "2026-02-06",
    "text": "Pull request reviews are a courtesy and a favor, not owed. You're requesting someone's valuable time to help you avoid mistakes, since ultimately you're responsible for any mess you merge. Ask nicely.",
    "tags": ["engineering-culture"]
  },
  {
    "slug": "strive-for-all-adds",
    "date": "2026-02-06",
    "text": "Strive for all 'adds' in pull requests. If you have very few lines deleted/modified, it's a good sign your codebase is modular and maintainable.",
    "tags": ["engineering-process"]
  },
  {
    "slug": "never-request-changes",
    "date": "2026-02-06",
    "text": "Never use GitHub's 'Request Changes' feature. It encourages a confrontational style of code review. Remember that #pr-reviews-are-a-courtesy.",
    "tags": ["engineering-culture"]
  },
  {
    "slug": "quick-reviews",
    "date": "2026-02-06",
    "text": "Strive to review small PRs quickly. This incentivizes small diffs, provides immediate reward signals for hard work, and builds trust and goodwill within a team.",
    "tags": ["engineering-culture"]
  },
  {
    "slug": "delete-code-liberally",
    "date": "2026-02-06",
    "text": "Don't be afraid to delete unused code. Code is cheap and git is good. If something isn't directly contributing to your mission and won't in the immediate future, delete it. It can always be resurrected if needed.",
    "tags": ["engineering-process"]
  },
  {
    "slug": "reviews-are-static",
    "date": "2026-02-06",
    "text": "Code review is purely static analysis. It's the pull request author's responsibility to test runtime behavior of their code, not reviewers'.",
    "tags": ["engineering-process"]
  },
  {
    "slug": "set-up-structured-logging-early",
    "date": "2026-02-06",
    "text": "Set up structured logging early. You get 90% of the value of all observability tooling just be having quality logging from the start.",
    "tags": ["engineering-process"]
  },
  {
    "slug": "speed-quality-tradeoff",
    "date": "2026-02-06",
    "text": "If you always choose execution speed over quality, good luck maintaining that speed. Consider second and third order effects. Remember that this tradeoff is a balancing act and always situationally dependent.",
    "tags": ["engineering-process"]
  }
]
